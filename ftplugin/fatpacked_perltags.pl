#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Perl/Tags.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_PERL_TAGS';
  #!/usr/bin/env perl
  use 5.006;
  use strict; use warnings;
  
  package App::Perl::Tags;
  use Getopt::Long ();
  use Pod::Usage qw/pod2usage/;
  use File::Find::Rule;
  
  use Perl::Tags;
  use Perl::Tags::Hybrid;
  use Perl::Tags::Naive::Moose; # includes ::Naive
  
  our $VERSION = '0.032';
  
  sub run {
    my $class = shift;
  
    my %options = (
      outfile => 'perltags',
      files => undef,
      depth => 10,
      variables => 1,
      ppi => 0,
      prune => [ ],
      help => sub { $class->usage() },
      version => sub { $class->version() },
    );
  
    Getopt::Long::GetOptions(
      \%options,
      'help|h',
      'version|v',
      'outfile|o=s',
      'files|L=s',
      'prune=s@',
      'depth|d=i',
      'variables|vars!',
      'ppi|p!',
    );
  
    if (defined $options{files}) {
      # Do not descend into explicitly specified files.
      $options{depth} = 1;
    } else {
      # If not files are specified via -files options, we expect some
      # paths after all the options.
      $class->usage() unless @ARGV
    }
  
    $options{paths} = \@ARGV;
  
    my $self = $class->new(%options);
    $self->main();
    exit();
  }
  
  sub new {
    my ($class, %options) = @_;
    $options{prune} = [ '.git', '.svn' ] unless @{ $options{prune} || [] };
    return bless \%options, $class;
  }
  
  sub version {
    print "perl-tags v. $VERSION (Perl Tags v. $Perl::Tags::VERSION)\n";
    exit();
  }
  
  sub usage {
    pod2usage(0);
  }
  
  sub main {
    my $self = shift;
  
    my %args = (
      max_level    => $self->{depth},
      exts         => 1,
      do_variables => $self->{variables},
    );
  
    my @taggers = ( Perl::Tags::Naive::Moose->new( %args ) );
    if ($self->{ppi}) {
      require Perl::Tags::PPI;
      push @taggers, Perl::Tags::PPI->new( %args );
    }
  
    my $ptag = Perl::Tags::Hybrid->new( %args, taggers => \@taggers );
  
    my @files = do {
      if (defined $self->{files}) {
        if ('-' eq $self->{files}) {
          map { chomp; $_ } <STDIN>;
        } else {
          my $fh = IO::File->new($self->{files})
            or die "cannot open $$self{files} for reading: $!";
          map { chomp; $_ } <$fh>;
        }
      } else {
        $self->get_files;
      }
    };
  
    $ptag->process(files => \@files);
    $ptag->output(outfile => $self->{outfile}); 
    return;
  }
  
  sub get_files {
    my $self = shift;
    my @prune = @{ $self->{prune} };
    my @paths = @{ $self->{paths} };
  
    my $rule = File::Find::Rule->new;
  
    my @files = 
      $rule->or(
        $rule->new
             ->directory
             ->name(@prune)
             ->prune
             ->discard,
        $rule->new
          ->file,
      )->in(@paths);
  
    return @files;
  }
  
  =head1 AUTHOR
  
  Copyright 2009-2014, Steffen Mueller, with contributions from osfameron
  
  =cut
  
  # vim:ts=2:sw=2
  
  1;
APP_PERL_TAGS

$fatpacked{"Module/Locate.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_LOCATE';
  {
    package Module::Locate;
  
    use warnings;
    use 5.8.8;
  
    our $VERSION  = '1.79';
    our $Cache    = 0;
    our $Global   = 1;
  
    my $ident_re = qr{[_a-z]\w*}i;
    my $sep_re   = qr{'|::};
    our $PkgRe    = qr{\A(?:$ident_re(?:$sep_re$ident_re)*)\z};
  
    my @All      = qw(
      locate get_source acts_like_fh
      mod_to_path is_mod_loaded is_pkg_loaded
    );
  
    sub import {
      my $pkg = caller;
      my @args = @_[ 1 .. $#_ ];
      
      while(local $_ = shift @args) {
        *{ "$pkg\::$_" } = \&$_ and next
          if defined &$_;
  
        $Cache = shift @args, next
          if /^cache$/i;
  
        $Global = shift @args, next
          if /^global$/i;
  
        if(/^:all$/i) {
          *{ "$pkg\::$_" } = \&$_
            for @All;
          next;
        }
  
        warn("not in ".__PACKAGE__." import list: '$_'");
      }
    }
  
    use strict;
  
    use IO::File;
    use overload ();
    use Carp 'croak';
    use File::Spec::Functions 'catfile';
    
    sub get_source {
      my $pkg = $_[-1];
  
      my $f = locate($pkg);
  
      my $fh = ( acts_like_fh($f) ?
        $f
      :
        do { my $tmp = IO::File->new($f)
               or croak("invalid module '$pkg' [$f] - $!"); $tmp }
      );
  
      local $/;
      return <$fh>;
    }
    
    sub locate {
      my $pkg = $_[-1];
  
      croak("Undefined filename provided")
        unless defined $pkg;
        
      my $inc_path = mod_to_path($pkg);
  
      return $INC{$inc_path} if exists($INC{$inc_path}) && !wantarray;
  
      # On Windows the inc_path will use '/' for directory separator,
      # but when looking for a module, we need to use the OS's separator.
      my $partial_path = _mod_to_partial_path($pkg);
  
      my @paths;
  
      for(@INC) {
        if(ref $_) {
          my $ret = coderefs_in_INC($_, $inc_path);
  
          next
            unless defined $ret;
  
          croak("invalid \@INC subroutine return $ret")
            unless acts_like_fh($ret);
  
          return $ret;
        }
  
        my $fullpath = catfile($_, $partial_path);
        push(@paths, $fullpath) if -f $fullpath;
      }
  
      return unless @paths > 0;
  
      return wantarray ? @paths : $paths[0];
    }
  
    sub mod_to_path {
      my $pkg  = shift;
      my $path = $pkg;
  
      croak("Invalid package name '$pkg'")
        unless $pkg =~ $Module::Locate::PkgRe;
  
      # %INC always uses / as a directory separator, even on Windows
      $path =~ s!::!/!g;
      $path .= '.pm' unless $path =~ m!\.pm$!;
  
      return $path;
    }
  
    sub coderefs_in_INC {
      my($path, $c) = reverse @_;
  
      my $ret = ref($c) eq 'CODE' ?
        $c->( $c, $path )
      :
        ref($c) eq 'ARRAY' ?
          $c->[0]->( $c, $path )
        :
          UNIVERSAL::can($c, 'INC') ?
            $c->INC( $path )
          :
            warn("invalid reference in \@INC '$c'")
      ;
  
      return $ret;
    }
  
    sub acts_like_fh {
      no strict 'refs';
      return ( ref $_[0] and (
           ( ref $_[0] eq 'GLOB' and defined *{$_[0]}{IO} )
        or ( UNIVERSAL::isa($_[0], 'IO::Handle')          )
        or ( overload::Method($_[0], '<>')                )
      ) or ref \$_[0] eq 'GLOB' and defined *{$_[0]}{IO}  );
    }
  
    sub is_mod_loaded {
      my $mod  = shift;
      
      croak("Invalid package name '$mod'")
        unless $mod =~ $Module::Locate::PkgRe;
      
      ## it looks like %INC entries automagically use / as a separator
      my $path = join '/', split '::' => "$mod.pm";
  
      return (exists $INC{$path} && defined $INC{$path});
    }
  
    sub _mod_to_partial_path {
      my $package = shift;
  
      return catfile(split(/::/, $package)).'.pm';
    }
  
    sub is_pkg_loaded {
      my $pkg = shift;
  
      croak("Invalid package name '$pkg'")
        unless $pkg =~ $Module::Locate::PkgRe;
  
      my @tbls = map "${_}::", split('::' => $pkg);
      my $tbl  = \%main::;
      
      for(@tbls) {
        return unless exists $tbl->{$_};
        $tbl = $tbl->{$_};
      }
      
      return !!$pkg;
    }
  }
  
  q[ That better be make-up, and it better be good ];
  
  =pod
  
  =head1 NAME
  
  Module::Locate - locate modules in the same fashion as C<require> and C<use>
  
  =head1 SYNOPSIS
  
    use Module::Locate qw/ locate get_source /;
    
    add_plugin( locate "This::Module" );
    eval 'use strict; ' . get_source('legacy_code.plx');
  
  =head1 DESCRIPTION
  
  Using C<locate()>, return the path that C<require> would find for a given
  module or filename (it can also return a filehandle if a reference in C<@INC>
  has been used). This means you can test for the existence, or find the path
  for, modules without having to evaluate the code they contain.
  
  This module also comes with accompanying utility functions that are used within
  the module itself (except for C<get_source>) and are available for import.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item C<import>
  
  Given function names, the appropriate functions will be exported into the
  caller's package.
  
  If C<:all> is passed then all subroutines are exported.
  
  The B<Global> and B<Cache> options are no longer supported.
  See the BUGS section below.
  
  
  =item C<locate($module_name)>
  
  Given a module name as a string (in standard perl bareword format) locate the
  path of the module. If called in a scalar context the first path found will be
  returned, if called in a list context a list of paths where the module was
  found. Also, if references have been placed in C<@INC> then a filehandle will
  be returned, as defined in the C<require> documentation. An empty C<return> is
  used if the module couldn't be located.
  
  As of version C<1.7> a filename can also be provided to further mimic the lookup
  behaviour of C<require>/C<use>.
  
  =item C<get_source($module_name)>
  
  When provided with a package name, gets the path using C<locate()>.
  If C<locate()> returned a path, then the contents of that file are returned
  by C<get_source()> in a scalar.
  
  =item C<acts_like_fh>
  
  Given a scalar, check if it behaves like a filehandle. Firstly it checks if it
  is a bareword filehandle, then if it inherits from C<IO::Handle> and lastly if
  it overloads the C<E<lt>E<gt>> operator. If this is missing any other standard
  filehandle behaviour, please send me an e-mail.
  
  =item C<mod_to_path($module_name)>
  
  Given a module name,
  converts it to a relative path e.g C<Foo::Bar> would become C<Foo/Bar.pm>.
  
  Note that this path will always use '/' for the directory separator,
  even on Windows,
  as that's the format used in C<%INC>.
  
  =item C<is_mod_loaded($module_name)>
  
  Given a module name, return true if the module has been
  loaded (i.e exists in the C<%INC> hash).
  
  =item C<is_pkg_loaded($package_name)>
  
  Given a package name (like C<locate()>), check if the package has an existing
  symbol table loaded (checks by walking the C<%main::> stash).
  
  =back
  
  =head1 SEE ALSO
  
  A review of modules that can be used to get the path (and often other information)
  for one or more modules: L<http://neilb.org/reviews/module-path.html>.
  
  L<App::Module::Locate> and L<mlocate>.
  
  =head1 REPOSITORY
  
  L<https://github.com/neilbowers/Module-Locate>
  
  =head1 BUGS
  
  In previous versions of this module, if you specified C<Global =E<gt> 1>
  when use'ing this module,
  then looking up a module's path would update C<%INC>,
  even if the module hadn't actually been loaded (yet).
  This meant that if you subsequently tried to load the module,
  it would wrongly not be loaded.
  
  Bugs are tracked using RT (bug you can also raise Github issues if you prefer):
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Module-Locate>
  
  =head1 AUTHOR
  
  Dan Brook C<< <cpan@broquaint.com> >>
  
  =head1 LICENSE
  
  This is free software; you can redistribute it and/or modify it under the same terms as
  Perl itself.
  
  =cut
MODULE_LOCATE

$fatpacked{"Perl/Tags.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS';
  #!/usr/bin/perl
  
  =head1 NAME
  
  Perl::Tags - Generate (possibly exuberant) Ctags style tags for Perl sourcecode
  
  =head1 SYNOPSIS
  
  =head2 Using Perl::Tags to assist your development
  
  C<Perl::Tags> is designed to be integrated into your development
  environment.  Here are a few ways to use it:
  
  =head3 With Vim
  
  C<Perl::Tags> was originally designed to be used with vim.  See
  L<https://github.com/osfameron/perl-tags-vim> for an easily installable Plugin.
  
  NB: You will need to have a vim with perl compiled in it.  Debuntu packages
  this as C<vim-perl>. Alternatively you can compile from source (you'll need
  Perl + the development headers C<libperl-dev>).
  
  (Note that C<perl-tags-vim> includes its own copy of C<Perl::Tags> through
  the magic of git submodules and L<App::FatPacker>, so you don't need to install
  this module from CPAN if you are only intending to use it with Vim as above!)
  
  =head3 From the Command Line
  
  See the L<bin/perl-tags> script provided.
  
  =head3 From other editors
  
  Any editor that supports ctags should be able to use this output.  Documentation
  and code patches on how to do this are welcome.
  
  =head2 Using the Perl::Tags module within your code
  
          use Perl::Tags;
          my $naive_tagger = Perl::Tags::Naive->new( max_level=>2 );
          $naive_tagger->process(
              files => ['Foo.pm', 'bar.pl'],
              refresh=>1 
          );
  
          print $naive_tagger; # stringifies to ctags file
  
  Recursively follows C<use> and C<require> statements, up to a maximum
  of C<max_level>.
  
  =head1 DETAILS
  
  There are several taggers distributed with this distribution, including:
  
  =over 4
  
  =item L<Perl::Tags::Naive> 
  
  This is a more-or-less straight ripoff, slightly updated, of the original
  pltags code.  This is a "naive" tagger, in that it makes pragmatic assumptions
  about what Perl code usually looks like (e.g. it doesn't actually parse the
  code.)  This is fast, lightweight, and often Good Enough.
  
  This has additional subclasses such as L<Perl::Tags::Naive::Moose> to parse
  Moose declarations, and L<Perl::Tags::Naive::Lib> to parse C<use lib>.
  
  =item L<Perl::Tags::PPI>
  
  Uses the L<PPI> module to do a deeper analysis and parsing of your Perl code.
  This is more accurate, but slower.
  
  =item L<Perl::Tags::Hybrid>
  
  Can run multiple taggers, such as ::Naive and ::PPI, combining the results.
  
  =back
  
  =head1 EXTENDING
  
  Documentation patches are welcome: in the meantime, have a look at
  L<Perl::Tags::Naive> and its subclasses for a simple line-by-line method of
  tagging files.  Alternatively L<Perl::Tags::PPI> uses L<PPI>'s built in
  method of parsing Perl documents.
  
  In general, you will want to override the C<get_tags_for_file> method,
  returning a list of C<Perl::Tags::Tag> objects to be registered.
  
  For recursively checking other modules, return a C<Perl::Tags::Tag::Recurse>
  object, which does I<not> create a new tag in the resulting perltags file,
  but instead processes the next file recursively.
  
  =head1 FEATURES
  
      * Recursive, incremental tagging.
      * parses `use_ok`/`require_ok` line from Test::More
  
  =head1 METHODS
  
  =cut
  
  package Perl::Tags;
  
  use strict; use warnings;
  
  use Perl::Tags::Tag;
  use Data::Dumper;
  use File::Spec;
  
  our $VERSION = '0.32';
  $VERSION = eval $VERSION;
  
  use overload q("") => \&to_string;
  
  =head2 C<new>
  
  L<Perl::Tags> is an abstract baseclass.  Use a class such as 
  L<Perl::Tags::Naive> and instantiate it with C<new>.
  
      $naive_tagger = Perl::Tags::Naive->new( max_level=>2 );
  
  Accepts the following parameters
  
      max_level:    levels of "use" statements to descend into, default 2
      do_variables: tag variables?  default 1 (true)
      exts:         use the Exuberant extensions
  
  =cut
  
  sub new {
      my $class = shift;
      my %options = (
          max_level    => 2, # go into next file, but not down the whole tree
          do_variables => 1, 
          @_);
  
      my $self = \%options;
  
      return bless $self, $class;
  }
  
  =head2 C<to_string>
  
  A L<Perl::Tags> object will stringify to a textual representation of a ctags
  file.
  
      print $tagger;
  
  =cut
  
  sub to_string {
      my $self = shift;
      my $tags = $self->{tags} or return '';
      my %tags = %$tags;
  
      my $s; # to test
  
      my @lines;
  
      # the structure is an HoHoA of
      #
      #   {tag_name}
      #       {file_name}
      #           [ tags ]
      #
      #   where the file_name level is to allow us to prioritize tags from
      #   first-included files (on the basis that they may well be the files we
      #   want to see first.
  
      my $ord = $self->{order};
      my @names = sort keys %$tags;
      for (@names) {
          my $files = $tags{$_};
          push @lines, map { @{$files->{$_}} } 
              sort { $ord->{$a} <=> $ord->{$b} } keys %$files;
      }
      return join "\n", @lines;
  }
  
  =head2 C<clean_file>
  
  Delete all tags, but without touching the "order" seen, that way, if the tags
  are recreated, they will remain near the top of the "interestingness" tree
  
  =cut
  
  sub clean_file {
      my ($self, $file) = @_;
      
      my $tags = $self->{tags} or die "Trying to clean '$file', but there's no tags";
      
      for my $name (keys %$tags) {
          delete $tags->{$name}{$file};
      }
      delete $self->{seen}{$file};
      # we don't delete the {order} though
  }
  
  =head2 C<output>
  
  Save the file to disk if it has changed.  (The private C<{is_dirty}> attribute
  is used, as the tags object may be made up incrementally and recursively within
  your IDE.
  
  =cut
  
  sub output {
      my $self = shift;
      my %options = @_;
      my $outfile = $options{outfile} or die "No file to write to";
  
      return unless $self->{is_dirty} || ! -e $outfile;
  
      open (my $OUT, '>', $outfile) or die "Couldn't open $outfile for write: $!";
  	binmode STDOUT, ":encoding(UTF-8)";
      print $OUT $self;
      close $OUT or die "Couldn't close $outfile for write: $!";
  
      $self->{is_dirty} = 0;
  }
  
  =head2 C<process>
  
  Scan one or more Perl file for tags
  
      $tagger->process( 
          files => [ 'Module.pm',  'script.pl' ] 
      );
      $tagger->process(
          files   => 'script.pl',
          refresh => 1,
      );
  
  =cut
  
  sub process {
      my $self = shift;
      my %options = @_;
      my $files = $options{files} || die "No file passed to process";
      my @files = ref $files ? @$files : ($files);
  
      $self->queue( map { 
                            { file=>$_, level=>1, refresh=>$options{refresh} } 
                        } @files);
  
      while (my $file = $self->popqueue) {
          $self->process_item( %options, %$file );
      }
      return 1;
  }
  
  =head2 C<queue>, C<popqueue>
  
  Internal methods managing the processing
  
  =cut
  
  sub queue {
      my $self = shift;
      for (@_) {
          push @{$self->{queue}}, $_ unless $_->{level} > $self->{max_level};
      }
  }
  
  sub popqueue {
      my $self = shift;
      return pop @{$self->{queue}};
  }
  
  =head2 C<process_item>, C<process_file>, C<get_tags_for_file>
  
  Do the heavy lifting for C<process> above.  
  
  Taggers I<must> override the abstract method C<get_tags_for_file>.
  
  =cut
  
  sub process_item {
      my $self = shift;
      my %options = @_;
      my $file  = $options{file} || die "No file passed to proces";
  
      # make filename absolute, (this could become an option if appropriately
      # refactored) but because of my usage (tags_$PID file in /tmp) I need the
      # absolute path anyway, and it prevents the file being included twice under
      # slightly different names (unless you have 2 hardlinked copies, as I do
      # for my .vim/ directory... bah)
  
      $file = File::Spec->rel2abs( $file ) ;
  
      if ($self->{seen}{$file}++) {
          return unless $options{refresh};
          $self->clean_file( $file );
      }
  
      $self->{is_dirty}++; # we haven't yet been written out
  
      $self->{order}{$file} = $self->{curr_order}++ || 0;
  
      $self->{current} = {
          file          => $file,
          package_name  => '',
          has_subs      => 0,
          var_continues => 0,
          level         => $options{level},
      };
  
      $self->process_file( $file );
  
      return $self->{tags};
  }
  
  sub process_file {
      my ($self, $file) = @_;
  
      my @tags = $self->get_tags_for_file( $file );
  
      $self->register( $file, @tags );
  }
  
  sub get_tags_for_file {
      use Carp 'confess';
      confess "Abstract method get_tags_for_file called";
  }
  
  =head2 C<register>
  
  The parsing is done by a number of lightweight objects (parsers) which look for
  subroutine references, variables, module inclusion etc.  When they are
  successful, they call the C<register> method in the main tags object.
  
  Note that if your tagger wants to register not a new I<declaration> but rather
  a I<usage> of another module, then your tagger should return a
  C<Perl::Tags::Tag::Recurse> object.  This is a pseudo-tag which causes the linked
  module to be scanned in turn.  See L<Perl::Tags::Naive>'s handling of C<use>
  statements as an example!
  
  =cut
  
  sub register {
      my ($self, $file, @tags) = @_;
      for my $tag (@tags) {
          $tag->on_register( $self ) or next;
          $tag->{pkg} ||=  $self->{current}{package_name};
          $tag->{exts} ||= $self->{exts};
  
          # and copy absolute file if requested
          # $tag->{file} = $file if $self->{absolute};
  
          my $name = $tag->{name};
          push @{ $self->{tags}{$name}{$file} }, $tag;
      }
  }
  
  ##
  1;
  
  =head1 SEE ALSO
  
  L<bin/perl-tags>
  
  =head1 CONTRIBUTIONS
  
  Contributions are always welcome.  The repo is in git:
  
      http://github.com/osfameron/perl-tags
  
  Please fork and make pull request.  Maint bits available on request.
  
  =over 4
  
  =item DMITRI
  
  many patches for features and bugfixes
  
  =item wolverian
  
  ::PPI subclass
  
  =item Ian Tegebo
  
  patch to use File::Temp
  
  =item drbean
  
  ::Naive::Moose, ::Naive::Spiffy and ::Naive::Lib subclasses
  
  =item Alias
  
  prodding me to make repo public
  
  =item tsee
  
  Command line interface, applying patches
  
  =item nothingmuch
  
  =item Andreas Koenig
  
  =item ether
  
  =back
  
  =head1 AUTHOR and LICENSE
  
      osfameron (2006-2014) - osfameron@cpan.org
                              and contributors, as above
  
  For support, try emailing me or grabbing me on irc #london.pm on irc.perl.org
  
  This was originally ripped off pltags.pl, as distributed with vim
  and available from L<http://www.mscha.com/mscha.html?pltags#tools>
  Version 2.3, 28 February 2002
  Written by Michael Schaap <pltags@mscha.com>. 
  
  This is licensed under the same terms as Perl itself.  (Or as Vim if you prefer).
  
  =cut
PERL_TAGS

$fatpacked{"Perl/Tags/Hybrid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_HYBRID';
  package Perl::Tags::Hybrid;
  
  use strict; use warnings;
  use parent 'Perl::Tags';
  
  our $VERSION = '0.32';
  
  =head1 C<Perl::Tags::Hybrid>
  
  Combine the results of multiple parsers, for example C<Perl::Tags::Naive>
  and C<Perl::Tags::PPI>.
  
  =head1 SYNOPSIS
  
      my $parser = Perl::Tags::Hybrid->new(
          taggers => [
              Perl::Tags::Naive->new,
              Perl::Tags::PPI->new,
          ],
      );
  
  =head2 C<get_tags_for_file>
  
  Registers the results from running each sub-taggers
  
  =cut
  
  sub get_taggers {
      my $self = shift;
      return @{ $self->{taggers} || [] };
  }
  
  sub get_tags_for_file {
      my ($self, $file) = @_;
  
      my @taggers = $self->get_taggers;
  
      return map { $_->get_tags_for_file( $file ) } @taggers;
  }
  
  1;
PERL_TAGS_HYBRID

$fatpacked{"Perl/Tags/Naive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_NAIVE';
  package Perl::Tags::Naive;
  
  use strict; use warnings;
  use parent 'Perl::Tags';
  
  our $VERSION = '0.32';
  
  =head1 C<Perl::Tags::Naive>
  
  A naive implementation.  That is to say, it's based on the classic C<pltags.pl>
  script distributed with Perl, which is by and large a better bet than the
  results produced by C<ctags>.  But a "better" approach may be to integrate this
  with PPI.
  
  =head2 Subclassing
  
  See L<TodoTagger> in the C<t/> directory of the distribution for a fully
  working example (tested in <t/02_subclass.t>).  You may want to reuse parsers
  in the ::Naive package, or use all of the existing parsers and add your own.
  
      package My::Tagger;
      use Perl::Tags;
      use parent 'Perl::Tags::Naive';
  
      sub get_parsers {
          my $self = shift;
          return (
              $self->can('todo_line'),     # a new parser
              $self->SUPER::get_parsers(), # all ::Naive's parsers
              # or maybe...
              $self->can('variable'),      # one of ::Naive's parsers
          );
      }
  
      sub todo_line { 
          # your new parser code here!
      }
      sub package_line {
          # override one of ::Naive's parsers
      }
  
  Because ::Naive uses C<can('parser')> instead of C<\&parser>, you
  can just override a particular parser by redefining in the subclass. 
  
  =head2 C<get_tags_for_file>
  
  ::Naive uses a simple line-by-line analysis of Perl code, comparing
  each line against an array of parsers returned by the L<get_parsers> method.
  
  The first of these parsers that matches (if any) will return the
  tag/control to be registred by the tagger.
  
  =cut
  
  {
      # Tags that start POD:
      my @start_tags = qw(pod head1 head2 head3 head4 over item back begin
                          end for encoding);
      my @end_tags = qw(cut);
  
      my $startpod = '^=(?:' . join('|', @start_tags) . ')\b';
      my $endpod = '^=(?:' . join('|', @end_tags) . ')\b';
  
      sub STARTPOD { qr/$startpod/ }
      sub ENDPOD { qr/$endpod/ }
  }
  
  sub get_tags_for_file {
      my ($self, $file) = @_;
  
      my @parsers = $self->get_parsers(); # function refs
  
      open (my $IN, '<', $file) or die "Couldn't open file `$file`: $!\n";
  
      my $start = STARTPOD();
      my $end = ENDPOD();
  
      my @all_tags;
  
      while (<$IN>) {
          next if (/$start/o .. /$end/o);     # Skip over POD.
          chomp;
          my $statement = my $line = $_;
          PARSELOOP: for my $parser (@parsers) {
              my @tags = $parser->( 
                  $self, 
                $line, 
                $statement,
                $file 
              );
              push @all_tags, @tags;
          }
      }
      return @all_tags;
  }
  
  =head2 C<get_parsers>
  
  The following parsers are defined by this module.
  
  =over 4
  
  =cut
  
  sub get_parsers {
      my $self = shift;
      return (
          $self->can('trim'),
          $self->can('variable'),
          $self->can('package_line'),
          $self->can('sub_line'),
          $self->can('use_constant'),
          $self->can('use_line'),
          $self->can('label_line'),
      );
  }
  
  =item C<trim>
  
  A filter rather than a parser, removes whitespace and comments.
  
  =cut
  
  sub trim {
      shift;
      # naughtily work on arg inplace
      $_[1] =~ s/#.*//;  # remove comment.  Naively
      $_[1] =~ s/^\s*//; # Trim spaces
      $_[1] =~ s/\s*$//;
  
      return;
  }
  
  =item C<variable>
  
  Tags definitions of C<my>, C<our>, and C<local> variables.
  
  Returns a L<Perl::Tags::Tag::Var> if found
  
  =cut
  
  sub variable {
      # don't handle continuing thingy for now
      my ($self, $line, $statement, $file) = @_;
  
      return unless $self->{do_variables}; 
          # I'm not sure I see this as all that useful
  
      if ($self->{var_continues} || $statement =~/^(my|our|local)\b/) {
  
          $self->{current}{var_continues} = ! ($statement=~/;$/);
          $statement =~s/=.*$//; 
              # remove RHS with extreme prejudice
              # and also not accounting for things like
              # my $x=my $y=my $z;
  
          my @vars = $statement=~/[\$@%]((?:\w|:)+)\b/g;
  
          # use Data::Dumper;
          # print Dumper({ vars => \@vars, statement => $statement });
  
          return map { 
              Perl::Tags::Tag::Var->new(
                  name => $_,
                  file => $file,
                  line => $line,
                  linenum => $.,
              ); 
          } @vars;
      }
      return;
  }
  
  =item C<package_line>
  
  Parse a package declaration, returning a L<Perl::Tags::Tag::Package> if found.
  
  =cut
  
  sub package_line {
      my ($self, $line, $statement, $file) = @_;
  
      if ($statement=~/^package\s+((?:\w|:)+)\b/) {
          return (
              Perl::Tags::Tag::Package->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<sub_line>
  
  Parse the declaration of a subroutine, returning a L<Perl::Tags::Tag::Sub> if found.
  
  =cut
  
  sub sub_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/sub\s+(\w+)\b/) {
          return (
              Perl::Tags::Tag::Sub->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
  
      return;
  }
  
  =item C<use_constant>
  
  Parse a use constant directive
  
  =cut
  
  sub use_constant {
      my ($self, $line, $statement, $file) = @_;
      if ($statement =~/^\s*use\s+constant\s+([^=[:space:]]+)/) {
          return (
              Perl::Tags::Tag::Constant->new(
                  name    => $1,
                  file    => $file,
                  line    => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<use_line>
  
  Parse a use, require, and also a use_ok line (from Test::More).
  Uses a dummy tag (L<Perl::Tags::Tag::Recurse> to do so).
  
  =cut
  
  sub use_line {
      my ($self, $line, $statement, $file) = @_;
  
      my @ret;
      if ($statement=~/^(?:use|require)(_ok\(?)?\s+(.*)/) {
          my @packages = split /\s+/, $2; # may be more than one if base
          @packages = ($packages[0]) if $1; # if use_ok ecc. from Test::More
  
          for (@packages) {
              s/^q[wq]?[[:punct:]]//;
              /((?:\w|:)+)/;
              $1 and push @ret, Perl::Tags::Tag::Recurse->new( 
                  name => $1, 
                  line=>'dummy' );
          }
      }
      return @ret;
  }
  
  =item C<label_line>
  
  Parse label declaration
  
  =cut
  
  sub label_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/^\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*:(?:[^:]|$)/) {
          return (
              Perl::Tags::Tag::Label->new(
                  name    => $1,
                  file    => $file,
                  line    => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =back
  
  =cut
  
  1;
PERL_TAGS_NAIVE

$fatpacked{"Perl/Tags/Naive/Lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_NAIVE_LIB';
  package Perl::Tags::Naive::Lib;
  
  use strict; use warnings;
  use parent 'Perl::Tags::Naive';
  
  our $VERSION = '0.32';
  
  =head2 C<get_parsers>
  
  The following parsers are defined by this module.
  
  =over 4
  
  =cut
  
  sub get_parsers
  {
          my $self = shift;
          return (
                  $self->SUPER::get_parsers(),
                  $self->can('uselib_line'),
          );
  }
  
  
  =item C<uselib_line>
  
  Parse a use/require lib line
  Unshift libraries found onto @INC.
  
  =cut
  
  sub uselib_line {
      my ($self, $line, $statement, $file) = @_;
  
      my @ret;
      if ($statement=~/^(?:use|require)\s+lib\s+(.*)/) {
          my @libraries = split /\s+/, $1; # may be more than one
  
          for (@libraries) {
              s/^q[wq]?[[:punct:]]//;
              /((?:\w|:)+)/;
              $1 and unshift @INC, $1;
          }
      }
      return @ret;
  }
  
  1;
  
  =back
  
  #package Perl::Tags::Tag::Recurse::Lib;
  #
  #our @ISA = qw/Perl::Tags::Tag::Recurse/;
  #
  #=head1 C<Perl::Tags::Tag::Recurse::Lib>
  #
  #=head2 C<type>: dummy
  #
  #=head2 C<on_register>
  #
  #Recurse adding this new module accessible from a use lib statement to the queue.
  #
  #=cut
  #
  #package Perl::Tags::Tag::Recurse;
  #
  #sub on_register {
  #    my ($self, $tags) = @_;
  #
  #    my $name = $self->{name};
  #    my $path;
  #    my @INC_ORIG = @INC;
  #    my @INC = 
  #    eval {
  #        $path = locate( $name ); # or warn "Couldn't find path for $module";
  #    };
  #    # return if $@;
  #    return unless $path;
  #    $tags->queue( { file=>$path, level=>$tags->{current}{level}+1 , refresh=>0} +);
  #    return; # don't get added
  #}
  
  ##
  
  1;
  
  =head1 AUTHOR and LICENSE
  
      dr bean - drbean at sign cpan a dot org
      osfameron (2006) - osfameron@gmail.com
  
  For support, try emailing me or grabbing me on irc #london.pm on irc.perl.org
  
  This was originally ripped off pltags.pl, as distributed with vim
  and available from L<http://www.mscha.com/mscha.html?pltags#tools>
  Version 2.3, 28 February 2002
  Written by Michael Schaap <pltags@mscha.com>.
  
  This is licensed under the same terms as Perl itself.  (Or as Vim if you +prefer).
  
  =cut
PERL_TAGS_NAIVE_LIB

$fatpacked{"Perl/Tags/Naive/Moose.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_NAIVE_MOOSE';
  use strict; use warnings;
  package Perl::Tags::Naive::Moose;
  
  use parent 'Perl::Tags::Naive';
  
  our $VERSION = '0.32';
  
  =head2 C<get_parsers>
  
  The following parsers are defined by this module.
  
  =over 4
  
  =cut
  
  sub get_parsers
  {
  	my $self = shift;
  	return (
  		$self->SUPER::get_parsers(),
  		$self->can('extends_line'),
  		$self->can('with_line'),
  		$self->can('has_line'),
  		$self->can('around_line'),
  		$self->can('before_line'),
  		$self->can('after_line'),
  		$self->can('override_line'),
  		$self->can('augment_line'),
  		$self->can('class_line'),
  		$self->can('method_line'),
  		$self->can('role_line'),
  	);
  }
  
  =item C<extends_line>
  
  Parse the declaration of a 'extends' Moose keyword, returning a L<Perl::Tags::Tag::Extends> if found.
  
  =cut
  
  sub extends_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/extends\s+["']?((?:\w+|::)+)\b/) {
  	return Perl::Tags::Tag::Recurse->new(
  	    name    => $1,
  	    line    => 'dummy',
  	);
      }
      return;
  }
  
  =item C<with_line>
  
  Parse the declaration of a 'with' Moose keyword, returning a L<Perl::Tags::Tag::With> tag if found.
  
  =cut
  
  sub with_line {
      my ( $self, $line, $statement, $file ) = @_;
      if ( $statement =~ m/\bwith\s+(?:qw.)?\W*([a-zA-Z0-9_: ]+)/ ) {
          my @roles = split /\s+/, $1;
          my @returns;
          foreach my $role (@roles) {
              push @returns, Perl::Tags::Tag::Recurse->new(
  		name    => $role,
  		line    => 'dummy',
              );
          }
          return @returns;
      }
      return;
  }
  
  =item C<has_line>
  
  Parse the declaration of a 'has' Moose keyword, returning a L<Perl::Tags::Tag::Has> if found.
  
  =cut
  
  sub has_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/\bhas\s+["']?(\w+)\b/) {
          return (
              Perl::Tags::Tag::Has->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<around_line>
  
  Parse the declaration of a 'around' Moose keyword, returning a L<Perl::Tags::Tag::Around> tag if found.
  
  =cut
  
  sub around_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/around\s+["'](\w+)\b/) {
          return (
              Perl::Tags::Tag::Around->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<before_line>
  
  Parse the declaration of a 'before' Moose keyword, returning a L<Perl::Tags::Tag::Before> tag if found.
  
  =cut
  
  sub before_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/before\s+["'](\w+)\b/) {
          return (
              Perl::Tags::Tag::Before->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<after_line>
  
  Parse the declaration of a 'after' Moose keyword, returning a L<Perl::Tags::Tag::After> tag if found.
  
  =cut
  
  sub after_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/after\s+["'](\w+)\b/) {
          return (
              Perl::Tags::Tag::After->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<override_line>
  
  Parse the declaration of a 'override' Moose keyword, returning a L<Perl::Tags::Tag::Override> tag if found.
  
  =cut
  
  sub override_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/override\s+["'](\w+)\b/) {
          return (
              Perl::Tags::Tag::Override->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<augment_line>
  
  Parse the declaration of a 'augment' Moose keyword, returning a L<Perl::Tags::Tag::Augment> tag if found.
  
  =cut
  
  sub augment_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/augment\s+["']?(\w+)\b/) {
          return (
              Perl::Tags::Tag::Augment->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<class_line>
  
  Parse the declaration of a 'class' Moose keyword, returning a L<Perl::Tags::Tag::Class> tag if found.
  
  =cut
  
  sub class_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/class\s+(\w+)\b/) {
          return (
              Perl::Tags::Tag::Class->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<method_line>
  
  Parse the declaration of a 'method' Moose keyword, returning a L<Perl::Tags::Tag::Method> tag if found.
  
  =cut
  
  sub method_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/method\s+(\w+)\b/) {
          return (
              Perl::Tags::Tag::Method->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<role_line>
  
  Parse the declaration of a 'role' Moose keyword, returning a L<Perl::Tags::Tag::Role> tag if found.
  
  =cut
  
  sub role_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/role\s+(\w+)\b/) {
          return (
              Perl::Tags::Tag::Role->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =head1 C<Perl::Tags::Tag::Method>
  
  =head2 C<type>: Method
  
  =cut
  
  package Perl::Tags::Tag::Method;
  our @ISA = qw/Perl::Tags::Tag::Sub/;
  
  sub type { 'Method' }
  
  
  =head1 C<Perl::Tags::Tag::Has>
  
  =head2 C<type>: Has
  
  =cut
  
  package Perl::Tags::Tag::Has;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'Has' }
  
  =head1 C<Perl::Tags::Tag::Around>
  
  =head2 C<type>: Around
  
  =cut
  
  package Perl::Tags::Tag::Around;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'Around' }
  
  =head1 C<Perl::Tags::Tag::Before>
  
  =head2 C<type>: Before
  
  =cut
  
  package Perl::Tags::Tag::Before;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'Before' }
  
  =head1 C<Perl::Tags::Tag::After>
  
  =head2 C<type>: After
  
  =cut
  
  package Perl::Tags::Tag::After;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'After' }
  
  =head1 C<Perl::Tags::Tag::Override>
  
  =head2 C<type>: Override
  
  =cut
  
  package Perl::Tags::Tag::Override;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'Override' }
  
  =head1 C<Perl::Tags::Tag::Augment>
  
  =head2 C<type>: Augment
  
  =cut
  
  package Perl::Tags::Tag::Augment;
  our @ISA = qw/Perl::Tags::Tag::Method/;
  
  sub type { 'Augment' }
  
  =head1 C<Perl::Tags::Tag::Class>
  
  =head2 C<type>: Class
  
  =cut
  
  package Perl::Tags::Tag::Class;
  our @ISA = qw/Perl::Tags::Tag::Package/;
  
  sub type { 'Class' }
  
  =head1 C<Perl::Tags::Tag::Role>
  
  =head2 C<type>: Role
  
  =cut
  
  package Perl::Tags::Tag::Role;
  our @ISA = qw/Perl::Tags::Tag::Package/;
  
  sub type { 'Role' }
  
  1;
  
  =head1 AUTHOR and LICENSE
  
      dr bean - drbean at sign cpan a dot org
  
  This is licensed under the same terms as Perl itself.  (Or as Vim if you +prefer).
  
  =cut
  
  # vim: set ts=8 sts=4 sw=4 noet:
PERL_TAGS_NAIVE_MOOSE

$fatpacked{"Perl/Tags/Naive/Spiffy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_NAIVE_SPIFFY';
  package Perl::Tags::Naive::Spiffy;
  
  use strict; use warnings;
  use parent 'Perl::Tags::Naive';
  
  our $VERSION = '0.32';
  
  =head2 C<get_parsers>
  
  The following parsers are defined by this module.
  
  =over 4
  
  =cut
  
  sub get_parsers
  {
  	my $self = shift;
  	return (
  		$self->SUPER::get_parsers(),
  		$self->can('field_line'),
  		$self->can('stub_line'),
  	);
  }
  
  =item C<field_line>
  
  Parse the declaration of a Spiffy class accessor method, returning a L<Perl::Tags::Tag::Field> if found.
  
  =cut
  
  sub field_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/field\s+["']?(\w+)\b/) {
          return (
              Perl::Tags::Tag::Field->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =item C<stub_line>
  
  Parse the declaration of a Spiffy stub method, returning a L<Perl::Tags::Tag::Stub> if found.
  
  =cut
  
  sub stub_line {
      my ($self, $line, $statement, $file) = @_;
      if ($statement=~/stub\s+["']?(\w+)\b/) {
          return (
              Perl::Tags::Tag::Stub->new(
                  name => $1,
                  file => $file,
                  line => $line,
                  linenum => $.,
              )
          );
      }
      return;
  }
  
  =back
  
  =head1 C<Perl::Tags::Tag::Field>
  
  =head2 C<type>: Field
  
  =cut
  
  package Perl::Tags::Tag::Field;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 'Field' }
  
  =head1 C<Perl::Tags::Tag::Stub>
  
  =head2 C<type>: Stub
  
  =cut
  
  package Perl::Tags::Tag::Stub;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 'Stub' }
  
  1;
  
  =head1 AUTHOR and LICENSE
  
      dr bean - drbean at sign cpan a dot org
      osfameron (2006) - osfameron@gmail.com
  
  For support, try emailing me or grabbing me on irc #london.pm on irc.perl.org
  
  This was originally ripped off pltags.pl, as distributed with vim
  and available from L<http://www.mscha.com/mscha.html?pltags#tools>
  Version 2.3, 28 February 2002
  Written by Michael Schaap <pltags@mscha.com>.
  
  This is licensed under the same terms as Perl itself.  (Or as Vim if you +prefer).
  
  =cut
PERL_TAGS_NAIVE_SPIFFY

$fatpacked{"Perl/Tags/PPI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_PPI';
  package Perl::Tags::PPI;
  
  use strict; use warnings;
  
  use base qw(Perl::Tags);
  
  use PPI;
  
  our $VERSION = '0.32';
  
  sub ppi_all {
      my ( $self, $file ) = @_;
  
      my $doc = PPI::Document->new($file) || return;
  
      $doc->index_locations;
  
      return map { $self->_tagify( $_, "$file" ) }
        @{ $doc->find(sub { $_[1]->isa("PPI::Statement") }) || [] }
  }
  
  sub get_tags_for_file {
      my ( $self, $file, @parsers ) = @_;
  
      my @tags = $self->ppi_all( $file );
  
      return @tags;
  }
  
  sub _tagify {
      my ( $self, $thing, $file ) = @_;
  
      my $class = $thing->class;
  
      my ( $first_line ) = split /\n/, $thing;
  
      if ( my ( $subtype ) = ( $class =~ /^PPI::Statement::(.*)$/ ) ) {
  
          my $method = "_tagify_" . lc($subtype);
  
          if ( $self->can($method) ) {
              return $self->$method( $thing, $file, $first_line );
          }
      }
  
      return $self->_tagify_statement($thing, $file, $first_line);
  }
  
  # catch all
  sub _tagify_statement {
      my ( $self, $thing, $file, $first_line ) = @_;
  
      return;
  }
  
  sub _tagify_sub {
      my ( $self, $thing, $file, $line ) = @_;
  
      return Perl::Tags::Tag::Sub->new(
          name    => $thing->name,
          file    => $file,
          line    => $line,
          linenum => $thing->location->[0],
          pkg     => $thing->guess_package
      );
  }
  
  sub _tagify_variable {
      my ( $self, $thing, $file, $line ) = @_;
      return map {
          Perl::Tags::Tag::Var->new(
              name    => $_,
              file    => $file,
              line    => $line,
              linenum => $thing->location->[0],
            )
      } $thing->variables;
  }
  
  sub _tagify_package {
      my ( $self, $thing, $file, $line ) = @_;
  
      return Perl::Tags::Tag::Package->new(
          name    => $thing->namespace,
          file    => $file,
          line    => $line,
          linenum => $thing->location->[0],
      );
  }
  
  sub _tagify_include {
      my ( $self, $thing, $file ) = @_;
  
      if ( my $module = $thing->module ) {
          return Perl::Tags::Tag::Recurse->new(
              name    => $module,
              line    => "dummy",
          );
      }
  
      return;
  }
  
  sub PPI::Statement::Sub::guess_package {
      my ($self) = @_;
  
      my $temp = $self;
      my $package;
  
      while (1) {
          $temp = $temp->sprevious_sibling
            or last;
  
          if ( $temp->class eq 'PPI::Statement::Package' ) {
              $package = $temp;
              last;
          }
      }
  
      return $package;
  }
  
  =head1 NAME
  
  Perl::Tags::PPI - use PPI to parse 
  
  =head1 DESCRIPTION
  
  This is a drop-in replacement for the basic L<Perl::Tags> parser.  Please see that module's
  perldoc, and test C<t/04_ppi.t> for details.
  
  (Doc patches very welcome!)
  
  =head1 AUTHOR
  
   (c) Wolverian 2006
  
  Modifications by nothingmuch
  
  =cut
  
  1;
PERL_TAGS_PPI

$fatpacked{"Perl/Tags/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PERL_TAGS_TAG';
  package Perl::Tags::Tag;
  use strict; use warnings;
  
  use overload q("") => \&to_string;
  
  our $VERSION = '0.32';
  
  =head2 C<new>
  
  Returns a new tag object
  
  =cut
  
  sub new {
      my $class = shift;
      my %options = @_;
  
      $options{type} = $class->type;
  
      # chomp and escape line
      chomp (my $line = $options{line});
  
      $line =~ s{\\}{\\\\}g;
      $line =~ s{/}{\\/}g;
      # $line =~ s{\$}{\\\$}g;
  
      my $self = bless {
          name   => $options{name},
          file   => $options{file},
          type   => $options{type},
          is_static => $options{is_static},
          line   => $line,
          linenum => $options{linenum},
          exts   => $options{exts}, # exuberant?
          pkg    => $options{pkg},  # package name
      }, $class;
  
      $self->modify_options();
      return $self;
  }
  
  =head2 C<type>, C<modify_options>
  
  Abstract methods
  
  =cut
  
  sub type {
      die "Tried to call 'type' on virtual superclass";
  }
  
  sub modify_options { return } # no change
  
  =head2 C<to_string>
  
  A tag stringifies to an appropriate line in a ctags file.
  
  =cut
  
  sub to_string {
      my $self = shift;
  
      my $name = $self->{name} or die;
      my $file = $self->{file} or die;
      my $line = $self->{line} or die;
      my $linenum = $self->{linenum};
      my $pkg  = $self->{pkg} || '';
  
      my $tagline = "$name\t$file\t/$line/";
  
      # Exuberant extensions
      if ($self->{exts}) {
          $tagline .= qq(;"\t$self->{type});
          $tagline .= "\tline:$linenum";
          $tagline .= ($self->{is_static} ? "\tfile:" : '');
          $tagline .= ($self->{pkg} ? "\tclass:$self->{pkg}" : '');
      }
      return $tagline;
  }
  
  =head2 C<on_register>
  
  Allows tag to meddle with process when registered with the main tagger object.
  Return false if want to prevent registration (e.g. for control tags such as
  C<Perl::Tags::Tag::Recurse>.)
  
  =cut
  
  sub on_register {
      # my $self = shift;
      # my $tags = shift;
      # .... do stuff in subclasses
  
      return 1;  # or undef to prevent registration
  }
  
  =head1 C<Perl::Tags::Tag::Package>
  
  =head2 C<type>: p
  
  =head2 C<modify_options>
  
  Sets static=0
  
  =head2 C<on_register>
  
  Sets the package name
  
  =cut
  
  package Perl::Tags::Tag::Package;
  our @ISA = qw/Perl::Tags::Tag/;
  
      # QUOTE:
          # Make a tag for this package unless we're told not to.  A
          # package is never static.
  
  sub type { 'p' }
  
  sub modify_options {
      my $self = shift;
      $self->{is_static} = 0;
  }
  
  sub on_register {
      my ($self, $tags) = @_;
      $tags->{current}{package_name} = $self->{name};
  }
  
  =head1 C<Perl::Tags::Tag::Var>
  
  =head2 C<type>: v
  
  =head2 C<on_register>
  
          Make a tag for this variable unless we're told not to.  We
          assume that a variable is always static, unless it appears
          in a package before any sub.  (Not necessarily true, but
          it's ok for most purposes and Vim works fine even if it is
          incorrect)
              - pltags.pl comments
  
  =cut
  
  package Perl::Tags::Tag::Var;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 'v' }
  
      # QUOTE:
  
  sub on_register {
      my ($self, $tags) = @_;
      $self->{is_static} = ( $tags->{current}{package_name} || $tags->{current}{has_subs} ) ? 1 : 0;
  
      return 1;
  }
  =head1 C<Perl::Tags::Tag::Sub>
  
  =head2 C<type>: s
  
  =head2 C<on_register>
  
          Make a tag for this sub unless we're told not to.  We assume
          that a sub is static, unless it appears in a package.  (Not
          necessarily true, but it's ok for most purposes and Vim works
          fine even if it is incorrect)
              - pltags comments
  
  =cut
  
  package Perl::Tags::Tag::Sub;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 's' }
  
  sub on_register {
      my ($self, $tags) = @_;
      $tags->{current}{has_subs}++ ;
      $self->{is_static}++ unless $tags->{current}{package_name};
  
      return 1;
  } 
  
  =head1 C<Perl::Tags::Tag::Constant>
  
  =head2 C<type>: c
  
  =cut
  
  package Perl::Tags::Tag::Constant;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 'c' }
  
  =head1 C<Perl::Tags::Tag::Label>
  
  =head2 C<type>: l
  
  =cut
  
  package Perl::Tags::Tag::Label;
  our @ISA = qw/Perl::Tags::Tag/;
  
  sub type { 'l' }
  
  =head1 C<Perl::Tags::Tag::Recurse>
  
  =head2 C<type>: dummy
  
  This is a pseudo-tag, see L<Perl::Tags/register>.
  
  =head2 C<on_register>
  
  Recurse adding this new module to the queue.
  
  =cut
  
  package Perl::Tags::Tag::Recurse;
  our @ISA = qw/Perl::Tags::Tag/;
  
  use Module::Locate qw/locate/;
  
  sub type { 'dummy' }
  
  sub on_register {
      my ($self, $tags) = @_;
  
      my $name = $self->{name};
      my $path;
      eval {
          $path = locate( $name ); # or warn "Couldn't find path for $name";
      };
      # return if $@;
      return unless $path;
      $tags->queue( { file=>$path, level=>$tags->{current}{level}+1 , refresh=>0} );
      return; # don't get added
  }
  
  1;
PERL_TAGS_TAG

$fatpacked{"Test/Perl/Tags.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_PERL_TAGS';
  package Test::Perl::Tags;
  
  use strict; use warnings;
  use parent 'Test::Builder::Module';
  
  use Path::Tiny 'path';
  
  our @EXPORT = qw(tag_ok);
  our $VERSION = '0.32';
  
  =head1 NAME
  
  Test::Perl::Tags - testing output of L<Perl::Tags>
  
  =head1 SYNOPSIS
  
      use Test::Perl::Tags;
  
      # do some tagging
      
      tag_ok $tagger,
          SYMBOL => 'path/to/file.pm' => 'searchable bookmark',
          'Description of this test';
  
      tag_ok $tagger,
          SYMBOL => 'path/to/file.pm' => 'searchable bookmark' => 'p' => 'line:3' => 'class:Test',
          'Add additional parameters for exuberant extension';
  
  =cut
  
  sub tag_ok {
      my ($tagger, $symbol, $path, $bookmark) = splice(@_, 0, 4);
      my $description = pop;
  
      my $canonpath = path($path)->absolute->canonpath;
  
      my $tag = join "\t",
          $symbol,
          $canonpath,
          "/$bookmark/";
  
      # exuberant extensions
      if (@_) {
          $tag .= join "\t",
              q<;">,
              @_; 
      }
  
      my $ok = $tagger =~ /
              ^
              \Q$tag\E
              $
              /mx;
      my $builder = __PACKAGE__->builder;
  
      $builder->ok( $ok, $description )
          or $builder->diag( "Tags did not match:\n$tag" );
  }
  
  1;
TEST_PERL_TAGS

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.234';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          push @{"$inheritor\::ISA"}, @_;
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007-10 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use Perl::Tags;
use Perl::Tags::Hybrid;
use Perl::Tags::Naive::Moose;

1;
